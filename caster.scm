;; Cast

(load "pmatch.scm")
(load "types.scm")


;; Syntactic Extensions
(define-syntax fn-erase
  (syntax-rules (:)
    ((_ (: v type))
     '(v))
    ((_ ((: v type) v2 ...))
     `(v ,@(fn-erase v2 ...)))))

(define-syntax fn
  ;; Can we avoid the use of eval here?
  (syntax-rules (:)
    ((_ (: v type) (: return) body ...)
     (lambda (v) body ...))
    ((_ (: v type) body ...)
     (lambda (v) body ...))
    ((_ ((: v type) v2 ...) (: return) body ...)
     (fn ((: v type) v2 ...) body ...))
    ((_ ((: v type) v2 ...) body ...)
     (let ((env (the-environment)))
       (eval `(lambda ,(fn-erase ((: v type) v2 ...)) body ...) env)))
    ((_ () body ...)
     (lambda () body ...))))

;; Helpers
(define (all-equal? ls)
  (or (or (null? ls) (null? (cdr ls)))
      (and (equal? (car ls) (cadr ls))
	   (all-equal? (cdr ls)))))

;; Type environments are hash tables now
(define (te/new)
  (make-hash-table))

(define (te/lookup te var)
  (hash-table/get te var #f))

(define (te/extend te var type)
  (hash-table/put! te var type)
  te)

(define (te/remove te var)
  (hash-table/remove! te var)
  te)

(define (te/nremove te vars)
  (for-each (lambda (v) (te/remove te v)) vars)
  te)

(define (te/merge te1 te2)
  (define (put-func h1 h2)
    (hash-table/for-each
     h2 (lambda (k v) (hash-table/put! h1 k v))))
  (let ((te (te/new))) (put-func te te1) (put-func te te2) te))

(define (te/nmerge tes)
  (fold-left (lambda (acc x) (te/merge acc x)) (car tes) tes))

(define (te/copy te)
  (let ((te-copy (te/new)))
    (hash-table/for-each
     te (lambda (k v) (hash-table/put! te-copy k v)))
    te-copy))

(define te->alist hash-table->alist)
(define (alist->te alist)
  (let ((te (te/new)))
    (for-each (lambda (e)
		(hash-table/put! te (car e) (cdr e))) alist)
    te))

;; Cast Judgements
(define-structure (cj) te exp type)
;; / is more readable than - at times
(define cj/te cj-te)
(define cj/exp cj-exp)
(define cj/type cj-type)

;; Dealing with casts
(define (cast? exp)
  (and (pair? exp) (eq? (car exp) ':)))
(define (make-cast exp type)
  `(: ,exp ,type))
(define (uncast exp)
  (and (cast? exp) (cadr exp)))
(define cast/exp uncast)
(define (cast/type exp)
  (and (cast? exp) (caddr exp)))

;; Transform to intermediate langugae
;; Returns a cast judgement
(define (transform exp te)
  (pmatch
   exp
   (,e (guard (number? e)) (make-cj te (make-cast e 'number) 'number))

   (,e (guard (string? e)) (make-cj te (make-cast e 'string) 'string))

   (,e (guard (boolean? e)) (make-cj te (make-cast e 'boolean) 'boolean))

   (,e (guard (char? e)) (make-cj te (make-cast e 'char) 'char))

   (,e (guard (symbol? e))
       (let ((binding (te/lookup te e))) ; te/lookup returns #f if e not bound
	 (if binding
	     (make-cj te (make-cast e binding) binding)
	     (make-cj (te/extend te e 'any) (make-cast e 'any) 'any))))

   ((fn (: ,v ,type) ,body)
    (let* ((new-te (te/extend (te/copy te) v type))
   	   (body-tf (transform body new-te))
   	   (cast-exp (make-cast `(fn (: ,v ,type) ,(cj/exp body-tf))
   				`(-> ,type ,(cj/type body-tf)))))
      (make-cj (te/merge (te/remove new-te v) te) cast-exp `(-> ,type ,(cj/type body-tf)))))

   ;; ((fn (: ,v ,type) ,body)
   ;;  (let* ((new-te (te/extend (te/copy te) v type))
   ;; 	   (body-tf (transform body new-te)))
   ;;    (begin
   ;; 	(display "Type of ") (display v) (display " in body : ")
   ;; 	(display (te/lookup (cj/te body-tf) v)) (newline)
   ;; 	(if (not (equal? (te/lookup (cj/te body-tf) v) type))
   ;; 	    (error "Cannot use " v 'as (te/lookup (cj/te body-tf) v))
   ;; 	    (let ((cast-exp (make-cast `(fn (: ,v ,type) ,(cj/exp body-tf))
   ;; 				       `(-> ,type ,(cj/type body-tf)))))
   ;; 	      (make-cj (te/merge (te/remove new-te v) te) cast-exp `(-> ,type ,(cj/type body-tf))))))))

   ((fn (: ,v ,type) (: ,ret-type) ,body)
    (let* ((new-te (te/extend (te/copy te) v type))
	   (body-tf (transform body new-te))
	   (co-domain-type (cj/type body-tf)))
      (if (~ co-domain-type ret-type)
	  (let ((cast-exp (make-cast `(fn (: ,v ,type) (: ,ret-type) ,(cj/exp body-tf))
				     `(-> ,type ,ret-type))))
	    (make-cj (te/merge (te/remove new-te v) te) cast-exp
		     `(-> ,type ,ret-type)))
	  (error "TypeError : " 'expected ret-type 'got co-domain-type))))
   
   ((fn ((: ,v ,type) . ,res) ,body)
    (let* ((bindings (map (lambda (x) (cons (cast/exp x) (cast/type x))) res))
	   (new-te (te/merge (te/copy te) (alist->te (cons (cons v type) bindings))))
	   (body-tf (transform body new-te))
	   (co-domain-type (cj/type body-tf))
	   (cast-exp (make-cast `(fn ((: ,v ,type) ,@res) ,(cj/exp body-tf))
				`(-> ,(list->pair-type (map (lambda (x) (cast/type x))
							    (cons `(: ,v ,type) res)))
				     ,co-domain-type))))
      (make-cj (te/merge te (te/nremove new-te
					(map (lambda (x) (car x))
					     (cons (cons v type) bindings))))
	       cast-exp (cast/type cast-exp))))
   ((fn ((: ,v ,type) . ,res) (: ,ret-type) ,body)
    (let* ((e-tf (transform `(fn ((: ,v ,type) . ,res) ,body) te))
	   (co-domain-type (cj/type e-tf)))
      (if (~ co-domain-type ret-type)
	  (let ((rt `(-> ,(list->pair-type (map (lambda (x) (cast/type x))
						(cons `(: ,v ,type) res)))
			 ,ret-type)))
	    (make-cj (cj/te e-tf) (make-cast (uncast (cj/exp e-tf)) rt) rt))
	  (error "TypeError : " 'expected ret-type 'got co-domain-type))))
   ((,rator ,rand)			   ; function with arity 1
    (let* ((rator-tf (transform rator te)) ; a cast judgement (cj) object
	   (rand-tf (transform rand te))
	   (rator-type (cj/type rator-tf))
	   (rand-type (cj/type rand-tf)))
      (if (any-type? rator-type)
	  (let ((new-te (te/merge (te/extend (cj/te rator-tf) rator `(-> ,rand-type any))
				  (cj/te rand-tf)))
		(cast-exp (make-cast (list (make-cast (uncast (cj/exp rator-tf))
						      `(-> ,rand-type any))
					   (cj/exp rand-tf)) 'any)))
	    (make-cj new-te cast-exp 'any))
	  (if (arrow-type? rator-type)
	      (if (equal? (domain rator-type) rand-type)
		  (let ((new-te (te/merge (cj/te rator-tf) (cj/te rand-tf)))
			(cast-exp (make-cast (list (cj/exp rator-tf) (cj/exp rand-tf))
					     (co-domain rator-type))))
		    (make-cj new-te cast-exp (co-domain rator-type)))
		  (if (and  (~ (domain rator-type) rand-type) (not (any-type? rand-type)))
		      (let ((new-te (te/merge (cj/te rator-tf)
					      ;; (te/extend (cj/te rand-tf)
					      ;; 		 rand (domain rator-type))
					      (cj/te rand-tf)
					      ))
			    (cast-exp (make-cast (list (cj/exp rator-tf)
						       (make-cast (uncast (cj/exp rand-tf))
								  (domain rator-type)))
						 (co-domain rator-type))))
			(make-cj new-te cast-exp (co-domain rator-type)))
		      (error "TypeError : " 'expected (domain rator-type) 'got rand-type)))
	      (error "TypeError : " rator 'must 'be 'a 'function)))))
   ((,rator . ,rands)
    (let* ((rator-tf (transform rator te))
	   (rator-type (cj/type rator-tf))
	   (rand-tf (map (lambda (e) (transform e te)) rands))
	   (rand-cast (map (lambda (e) (cj/exp e)) rand-tf))
	   (rand-type (list->pair-type (fold-right (lambda (x acc)
						     (cons (cj/type x) acc)) '() rand-tf))))
      (if (any-type? rator-type)
	  (let* ((new-te (te/nmerge (cons (te/extend (cj/te rator-tf) rator `(-> ,rand-type any))
					  (map (lambda (x) (cj/te x)) rand-tf))))
		 (cast-exp (make-cast `((: ,rator (-> ,rand-type any)) ,@rand-cast) 'any)))
	    (make-cj new-te cast-exp 'any))
	  (if (arrow-type? rator-type)
	      (if (or (equal? (domain rator-type) rand-type)
		      (and (equal? (arity rator-type) 'n)
			   (equal? (domain rator-type) (cadr rand-type))
			   (all-equal? (cdr rand-type))))
		  (let* ((new-te (te/nmerge (cons (cj/te rator-tf)
						  (map (lambda (x) (cj/te x)) rand-tf))))
			 (cast-exp `(: (,(cj/exp rator-tf) ,@rand-cast) ,(co-domain rator-type))))
		    (make-cj new-te cast-exp (co-domain rator-type)))
		  (if (or (~ (domain rator-type) rand-type)
			  (and (equal? (arity rator-type) 'n)
			       (~ (domain rator-type) (cadr rand-type))
			       (all-equal? (cdr rand-type))))
		      (let* ((rc (map (lambda (x y) (make-cast (uncast x) y))
				      rand-cast (cdr (domain rator-type))))
			     (rc-te (map (lambda (x y z) (te/extend (cj/te x) y z))
					 rand-tf rands (cdr (domain rator-type))))
			     (new-te (te/nmerge (cons (cj/te rator-tf) rc-te)))
			     (cast-exp `(: (,(cj/exp rator-tf) ,@rc) ,(co-domain rator-type))))
			(make-cj new-te cast-exp (co-domain rator-type)))
		      (begin (display rand-type)
			     (newline)
			     (display rator-type) (error "TypeError: " 'inconsistent 'argument 'types))))
	      (error "TypeError: " rator 'must 'be 'a 'function)))))
   (else (error "TRANSFORM -- Unknown type for --" exp))))

(define (c exp alis)
  (let ((res (transform exp (alist->te alis))))
    (display (cj/exp res)) (newline)
    (display "Γ = ") (display (te->alist (cj/te res)))
    (display " => ") (display exp)
    (display " : ") (display (cj/type res)) (newline)
    res))

;; Typing Judgements
(define-structure (tj) te exp type)
(define tj/te tj-te)
(define tj/exp tj-exp)
(define tj/type tj-type)

(define (check expr tenv)
  (define (tc exp type te)
    (pmatch
     exp
     ((: ,e ,t) (guard (and (~ type t) (not (equal? type t))))
      (display "Casting ") (display e) (display " from ") (display t) (display " to ")
      (display type) (newline)
      (tc `(: ,e ,type) type te))
     ((: ,e ,t) (guard (symbol? e))
      (let ((binding (te/lookup te e)))
	(if binding
	    (if (~ binding type)
		;; (make-tj (te/extend te e type) exp binding)
		(make-tj te exp binding)
		(error "TypeError: " 'expected binding 'got type))
	    ;; The part below never actually runs (?) need to test a bit more. 
	    (begin (display "Adding to TE: ") (display e) (display " : ") (display t) (newline)
		   (make-tj (te/extend e t) exp t)))))
     ((: (fn (: ,v ,s) ,body) ,t)
      ;; check consistency with t? 
      (let ((tc-body (tc body (co-domain type) (te/extend (te/copy te) v s))))
	(if (~ (tj/type tc-body) (co-domain type))
	    (make-tj (te/remove (tj/te tc-body) v) exp t)
	    (error "TypeError: " 'expected (co-domain type) 'got (tj/type tc-body)))))
     ((: (fn (: ,v ,s) (: ,ret) ,body) ,t)
      (let ((tc-body (tc body (co-domain type) (te/extend (te/copy te) v s))))
	(if (~ (tj/type tc-body) ret)
	    (make-tj (te/remove (tj/te tc-body) v) exp t)
	    (error "TypeError: " 'expected (co-domain type) 'got (tj/type tc-body)))))
     ((: (,rator ,rand) ,t)
      (let* ( ;; (tc-rator (tc rator `(-> ,(cast/type rand) ,type) te))
	     (tc-rator (tc rator (cast/type rator) te))
	     (tc-rand (tc rand (domain (cast/type rator)) te))
	     (new-te (te/merge (tj/te tc-rator) (tj/te tc-rand))))
	(make-tj new-te exp t)))
     ((: (,rator . ,rands) ,t)
      (let* ((tc-rator (tc rator (cast/type rator) te))
	     ;; Check each rand
	     (tc-rands (map (lambda (e) (tc e (cast/type e) te)) rands))
	     (rands-te (te/nmerge (map (lambda (e) (tj/te e)) tc-rands)))
	     (new-te (te/merge (tj/te tc-rator) rands-te)))
	(make-tj new-te exp t)))
     ((: ,e number) (guard (number? e)) (make-tj te exp 'number))
     ((: ,e string) (guard (string? e)) (make-tj te exp 'string))
     ((: ,e boolean) (guard (boolean? e)) (make-tj te exp 'boolean))
     ((: ,e char) (guard (char? e)) (make-tj te exp 'char))
     ((: ,e any) (make-tj te exp 'any))
     (else (error "Unknown type for --" exp))))
  (let ((c (transform expr ;; (alist->te tenv)
		      tenv)))
    (tc (cj/exp c) (cj/type c) (cj/te c))))

(define (t exp te)
  (let ((res (check exp (alist->te te))))
    ;; (display (tj/exp res))
    ;; (newline)
    (display "Γ{") (display (te->alist (tj/te res)))
    (display "} ⊦ ") (display exp)
    (display " : ") (display (tj/type res)) (newline)
    res))
