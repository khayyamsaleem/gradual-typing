#+STARTUP: noindent showall beamer
#+TITLE: Gradual Typing
#+OPTIONS: toc:t H:2 date:nil
#+BEAMER_FRAME_LEVEL: 2
#+LATEX_HEADER: \setbeamertemplate{navigation symbols}{}
#+SUBTITLE: An Introduction and an Implementation in MIT/GNU Scheme
#+latex_header: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Topic}\tableofcontents[currentsection]\end{frame}}
#+BEAMER_HEADER: \institute[CS810]{CS810 -- Type Systems for Programming Languages}
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+AUTHOR: Ramana Nagasamudram, Khayyam Saleem


* Gradual Typing
** Concept
   - Type system developed by Jeremy Siek and Walid Taha in 2006
   - Allows some parts of a program to be dynamically typed and other parts to be statically typed
     - Determined by presence of type annotation added by programmer
** Static Typing
   - Process of verifying the type safety of a program based on analysis of a program's source code
   - If a program passes a static type checker, then the program is guaranteed to satisfy some set of type safety properties for all possible inputs
   - Type checking completed during compilation process
     


*** Pros                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
    - Pros
     - catches bugs early
     - faster execution
     - improves modularity


*** Cons                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
    - Cons
     - makes code more verbose
     - prevents program execution
     
** Dynamic Typing
   - Process of type-checking at run-time
   - Associates each runtime object with a /type tag/

     
*** Pros                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
    - Pros
     - offers flexibility
     - doesn't get "in the way" of execution
     - allows for typing based on runtime information

*** Cons                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
    - Cons
     - cannot conclusively declare safety
     - errors may lie deep in subroutine calls
     - slower execution

** Utility of Gradual Typing
   - Gradual typing allows for type checks at compile-time for type errors in some parts of a program, directed by type annotations.
   - Since it is tough to declare that static typing is universally better or worse than dynamic typing, gradual typing offers the programmer a choice, without requiring a change in language
   - Provides a type system that:
     - allows programmers to choose the degree to which they want to annotate a program
     - allows programmers to use type annotations for static type checking as well as improving run-time performance
     - accepts programs written in a dynamically typed style 
     - on completely annotated programs, behaves just like a static type system

** Type Consistency
   | (CREFL) | $\tau \sim  \tau$                                                                                          |   |   | (CUNR) | $\tau \sim \thinspace ?$ |
   |         |                                                                                                   |   |   |        |                    |
   |         |                                                                                                   |   |   |        |                    |
   | (CFUN)  | $\frac{\sigma_1 \sim \tau_1  \quad    \sigma_2 \sim \tau_2}{\sigma_1 \rightarrow \sigma_2 \thinspace \thinspace \sim \thinspace \thinspace \tau_1 \rightarrow \tau_2}$ |   |   | (CUNL) | $? \thinspace \sim \tau$ |
* $\lambda_{\rightarrow}^?$
** Syntax
   [[./images/syntax.png]]
** Typing Rules
   [[./images/typing_rules.png]]
** Relation to simply-typed \lambda-calculus

   *Theorem:* If e \in $\lambda_\rightarrow$ then \emptyset \vdash_G e : \tau \equiv \emptyset \vdash_\rightarrow e : \tau
   ||
   ||
   ||
   Proof
** Run-time Semantics
   - Requires a cast insertion translation from $\lambda_\rightarrow^?$ to an intermediate language
   - 
* $\lambda_{\rightarrow}^{\langle\tau\rangle}$
** First-order example
** Higher-order example
** Type Safety
   $\lambda_\rightarrow^?$ is *type safe*; if evaluation terminates, the result is either a value of an expected type or a cast error, but not a type error.
   | |

   | *Theorem:* | If e \in \lambda_\rightarrow^{?} with type \tau can be converted to e' \in \lambda_\rightarrow^{\langle?\rangle  |
   |            | with type \tau, then it will evaluate to result \textbf{r}, |
   |            | \textbf{r} a value, CastError, or KillError.             |
* Implementation
** Existing Implementations
** MIT/GNU Scheme Implementation
   
